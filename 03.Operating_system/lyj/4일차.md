# 운영체제 4일차

## 가상메모리

**모든 프로세스**가 **메모리 내에 올라오지 않더라도 실행이 가능**하도록 하는 것입니다. 메모리에 적재되어 실행중인 프로세스가 메모리가 아닌 **가상의 공간을 참조**하여 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있도록 하는 것입니다. 즉, 각 프로그램에 실제 메모리 주소가 아닌 **가상의 메모리 주소를 할당**하는 방식입니다.

## 가상메모리 역할

가상메모리는 작은 메모리로도 **큰 가상 주소 공간**을 제공합니다. 메모리 크기의 제약으로부터 자유로워집니다.

프로그램을 메모리에 올리고 스왑(swap)하는데 필요한 입/출력 횟수가 줄어듭니다. 따라서 프로그램들이 **보다 빨리 실행**될 수 있습니다.

## 페이지 부재

**프로세스가 메인 메모리에 저장되지 않은 페이지를 사용**하려 할 때 발생합니다. 즉, 프로세스가 사용하려고 하는 **페이지가 메인 메모리에 없는** 경우를 맙합니다.

프로세스가 동작하면서 실제메모리에 필요한 데이터(페이지)가 없으면, 즉 페이지 폴트가 발생하면 **해당 페이지를 가상 메모리에서 찾게 됩니다**. 가상메모리는 하드디스크에 저장되어 있기 때문에, 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생합니다.

## Demand Paging

운영체제가 페이지 부재를 해결하기 위한 과정으로, **초기에 필요한 것들만 적재**하고 페이지들이 **실행 과정에서 실제로 필요할 때 적재**하는 것입니다. 한번도 접근되지 않는 페이지는 물리 메모리에 적재되지 않습니다.

**운영체제는 페이지 테이블(Page Table)로 가상 메모리를 관리합니다.** 운영체제는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. 

페이지 테이블에는 각 페이지가 저장되어있는 주소값이 들어있습니다. 페이지 테이블에 있는 **Valid bit를 이용해 해당 페이지가 어느 메모리에 있는지 표시**할 수 있습니다. 그러므로 운영체제는 페이지 테이블을이용하여 가상 메모리에서 페이지를 쉽게 찾을 수 있습니다.

CPU는 **프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회**합니다.

🔅**운영체제가 페이지 테이블을 이용하여 요구 페이징을 수행하는 과정**

```java
1. CPU는 물리 메모리을 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고
없으면 프로세스를 중단한다.
**4. 페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임(Free Frame)이 있는지 찾는다.**
5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
6. 중단되었던 CPU를 다시 시작한다.
```

프로세스를 멈출 수는 없으므로, **희생 프레임을 골라서 이를 가상 메모리에 저장 후 필요한 페이지를 물리 메모리에 로드** 한다. 그리고 이 과정에서 **페이지 교체 알고리즘(Page Replacement Algorithm)** 이 사용된다.

## 페이지 교체

페이지 부재가 발생하면 **빈 프레임이 없다면** 페이지 교체 알고리즘을 써서 대응합니다. 즉, **사용하지 않지만 메인 메모리에 있는 페이지**를 **디스크로 내보내고 새로운 페이지로 바꾸는 과정**입니다.

내보낼 페이지를 고를 때는 시스템의 효율성에 영향을 주므로 **페이지 부재 비율이 가장 낮은 알고리즘**을 선택합니다.

실제 필요한 페이지들만 메모리로 읽어오므로 사용되지 않는 페이지를 메모리로 가져오지 않음으로써  시간 낭비와 메모리 공간 낭비를 줄일 수 있습니다.

프로세스가 **메모리에 존재하는 페이지들만 접근**하는 실행은 **정상적**으로 진행됩니다.

프로세스가 **메모리에 올라와 있지 않는 페이지를 접근**하면 페이지 테이블 항목이 무효로 설정되어 있기 때문에 페이지 부재 트랩(page-fault trap)을 발생시킵니다.

## 페이지 교체 알고리즘

### **FIFO (First In First Out)**

가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, **먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다**는 것이다.

- **오래된 페이지**가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다.
- 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
- Belady의 모순: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

### **OPT (Optimal)**

 **가장 오랫동안 사용되지 않을 페이지를 찾아 교체**하는 것이다. 알고리즘 중 가장 낮은 페이지 부재율을 보장한다. 하지만 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

### **LRU (Least Recently Used) ❤**

**가장 오랫동안 사용되지 않은 페이지를 선택하여 교체**한다.

### **LFU (Least Frequently Used)**

**참조 횟수가 가장 적은 페이지를 교체**하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

### **MFU (Most Frequently Used)**

MFU: Most Frequently Used **참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정**에 기반한다.

## 캐시

캐시 메모리(이하 캐시)란 **데이터를 미리 복사**해두는 임시 저장공간을 말합니다. 캐시까지의 데이터 접근시간이 원래 데이터를 접근하는 시간에 비해 월등히 빠르기 때문에 캐시를 사용합니다. 자주 사용되는 데이터들을 캐시에 올려서 사용함으로써, 데이터 접근시간을 줄여 CPU성능을 효율적으로 사용할 수 있습니다.

## 캐시 메모리가 필요한 이유

**속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상**을 줄이기 위함입니다. 즉,  메모리와 cpu간의 속도 차이를 좁히기 위해서 **cpu가 앞으로 사용할 가능성이 많은 데이터를 미리 가져오는 것**입니다.

## 캐시의 지역성

cpu는 메모리에 접근하기 전에 먼저 캐시에 방문하여 필요한 데이터가 있는지 확인한다. **cpu가 캐시에서 원하는 데이터를 찾으면 Cache Hit, 못 찾으면 Cache miss**이다.

이 때 적중율(Hit rate)을 극대화 시키기 위해 **데이터 지역성(Locality)의 원리**를 사용한다. **지역성은** **동일한 값이나 관련 저장 위치를 자주 액세스**하는 것을 말한다.

지역성의 전제조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access 하지 않는다는 특성을 기본으로 한다. 즉, 지역성은 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다. **프로세스**는 어느 실행 단계 동안 메모리의 정보를 ~~균일하게 액세스~~하는 것이 아니라 **선호하는 특정 페이지만 집중적으로 참조하는 현상**으로 국부성이라고도 한다.

캐시의 지역성은 cpu의 Cache Hit를 높이기 위한 방법으로 두 가지가 있다.

- **시간적 지역성**

    한 번 조회된 메모리의 데이터는 Cache로서 다시 조회될 가능성이 더 높아진다

    순환(루프), 서브 프로그램, 스택, 계산이나 합계에 사용하는 변수

- **공간적 지역성**

    현재 메모리 위치에 가까운 데이터가 멀리 있는 데이터보다 캐시로써 조회될 가능성이 높다

    배열 검색(순회), 순차적 코드의 실행, 근처의 관련 변수 선언

## 파일

논리적인 저장 단위로 관련된 정보 자료들의 집합입니다.

## 파일 시스템

운영 체제에서 보조 기억 장치와 그 안에 저장되는 파일을 관리하는 시스템을 말합니다.

**운영체제**는 컴퓨터 시스템을 편리하게 사용하기 위해 **정보에 대한 일괄된 논리적 관점을 제공**하고 저장장치의 물리적 특성을 추상화하여 논리적 저장 단위, 즉 **파일을 정의**한다.

### **파일 시스템 마운팅**

**파일 시스템은 접근하기 전에 마운트 되어야 한다**. 마운트 되지 않은 파일 시스템은 마운트 지점 (Mount poing)에서 마운트된다.