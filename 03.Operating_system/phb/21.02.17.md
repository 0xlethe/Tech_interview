# 21.02.18

## 주요 질문
#### 💡 [스와핑이 무엇인가요?](#3-효과적인-메모리-사용)
* 메모리가 꽉 찬 경우 사용하지 않는 프로세스를 잠시 디스크로 내리고 (swap out) 새로운 프로세스를 올립니다. 그리고 내린 프로세스의 요청이 오면 다시 메모리로 올리는 (swap in) 것을 swapping이라고 합니다.

#### 💡 [페이징가 뭐에요?](#4-2-비연속-메모리-할당)
* 페이징은 가상 메모리를 동일한 크기인 페이지로 나누어 메모리를 할당하고 주소변환을 하는 기법입니다.

#### 💡 [세그먼테이션가 뭐에요?](#4-2-비연속-메모리-할당)
* 세그먼트는 가상 메모리를 세그먼트(서로 다른 크기)로 분할하여 메모리를 할당하고 주소변환 하는 기법입니다.

#### 💡 [내부단편화, 외부단편화를 설명해주세요](#5-메모리-단편화)
* 내부단편화는 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 공간이 낭비되는 것을 의미합니다.
* 외부단편화는 메모리 공간은 충분하지만 사용하지 않는 메모리가 쪼개어져 실제로는 프로세스를 할당할 수 없는 것을 의미합니다.

<br/>

## ⭐ 개념 정리
#### 논리주소/물리주소  

![image](https://user-images.githubusercontent.com/36289638/109377517-4db35200-790f-11eb-8c25-2a6c9cf59a86.png)

* 논리주소 : CPU가 메모리 접근하기 위해 임의의 연속된 메모리를 할당해 주는 주소
* 물리주소 : CPU가 제공하는 논리 주소와 매핑된 실제 메모리 주소  


<details>
    <summary>참고</summary>
    <ul>
    <li>http://truemind5.blogspot.com/2017/05/13.html</li>
    </ul>
</details>

<br/>

## **메모리 관리 전략**
### **1. 목적**  
메모리는 CPU가 직접 접근하는 유일한 저장장치로 메모리 시스템(HW)은 주소(메모리 위치)를 관리하며 할당과 접근을 제어  
* 제한된 물리 메모리의 효율적인 사용
* 효율적인 메모리 참조  

<br/>

### **2. 메모리에 프로그램 적재**  
* 빌드과정 : 소스파일 → 목적파일 → 실행파일
![image](https://user-images.githubusercontent.com/36289638/108358373-ff78c180-7231-11eb-987f-1d54aa790e04.png)  

* 링크단계에서 프로그램 실행 시 메인 메모리 할당  
* 생성된 프로그램은 code, data만 존재하며 메모리에 적재되면 stack 영역이 추가  

<br/>

### **3. 효과적인 메모리 사용**
* **동적 적재(Dynamic Loading)**  
    프로그램 실행에 반드시 필요한 루틴과 데이터만 적재  
    가끔 실행되는 코드는 실행 시 필요할 때 필요한 부분을 메모리에 적재

* **스와핑(Swapping)**  
    CPU에서 실행 중이지 않은 프로세스를 디스크로 보냈다가 다시 메모리에 적재

<details>
    <summary>참고</summary>
    <ul>
    <li>https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-12.-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EA%B4%80%EB%A6%AC</li>
    </ul>
</details>
<br/>

### **4. 메모리 할당 분류**
#### **4-1. 연속 메모리 할당**  
프로그램 전체가 메모리에 연속적으로 할당되는 관리 기법  

* **고정 분할 방식**  
    메모리를 동일한 크기로 미리 나누어 각 분할에 하나의 프로세스를 적재하여 실행하도록 하는 방식  
    ![image](https://user-images.githubusercontent.com/36289638/108349693-a7888d80-7226-11eb-98a5-1d5297568d8d.png)

* **가변 분할 방식**  
    프로그램의 크기를 고려하여 파티션의 크기 및 개수를 동적으로 바꾸는 방식  
    ![image](https://user-images.githubusercontent.com/36289638/108349771-bd964e00-7226-11eb-9f3f-70c0e77227f8.png)  

    |종류|설명|
    |-|-|
    |최초 적합(First Fit)|처음 만난 적절한 빈 공간에 프로세스 적재|
    |최적 적합(Best Fit)|가장 작은 공간에 적재|
    |최악 접합(Worst Fit)|가장 큰 공간에 적재|

<br/>

#### **4-2. 비연속 메모리 할당**  
프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법  

* **페이징(Paging)**  
    * 프로세스의 가상 메모리를 동일한 사이즈의 페이지 단위로 나누어 물리적 메모리를 불연속적으로 저장하는 방식 
    * 연속적이지 않은 공간에도 활용 가능하므로 외부단편화 해결   
    * 특정 프로세스의 몇 번째 페이지가 물리적 메모리의 몇 번쨰 프레임이 들어있다는 page mapping 정보 유지  
    * page mapping : 물리 메모리(프레임)-가상메모리(페이지) 대응을 위한 과정  
    ![image](https://user-images.githubusercontent.com/36289638/108355720-8c218080-722e-11eb-8cf8-1df85eac96ef.png)


* **세그먼테이션(Segmentation)**
    * 프로세스의 가상 메모리를 의미 단위인 세그먼트로 나누어 물리 메모리에 적재하는 방식  
    * 세그먼트(code, data, stack)의 크기가 서로 다르기 때문에 페이징 기법처럼 미리 분할 불가능  
    * 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법  
    * 페이징과 유사한 주소변환이지만 세그먼트 크기가 일정하지 않아 테이블에 limit 정보가 존재
    * 내부단편화 해결  
    ![image](https://user-images.githubusercontent.com/36289638/108355335-0ac9ee00-722e-11eb-9903-b8fa538bb4ae.png)


<details>
    <summary>참고</summary>
    <ul>
    <li>https://hibee.tistory.com/303</li>
    <li>https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95</li>
    <li>https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-14.-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98</li>
    </ul>
</details>

<br/>

### **5. 메모리 단편화**
메모리 공간이 낭비되는 것

#### **5-1. 내부단편화**  
* 프로세스가 필요한 양보다 더 큰 메모리가 할당  
* 4KB 공간에 1KB의 파일을 할당 → 내부 단편화 3KB

#### **5-2. 외부단편화**  
* 중간에 생긴 사용하지 않는 메모리가 많아 메모리 공간은 충분 하지만 실제로 할당할 수 없는 상황
* 6KB 공간에 1KB, 3KB, 2KB가 순서대로 할당 → 1KB, 2KB 종료 → 3KB 프로세스 할당 불가능 (외부 단편화)

