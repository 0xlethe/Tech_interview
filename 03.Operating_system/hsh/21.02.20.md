# 21.02.20

## 주요 질문

#### 💡
## 심화 질문

#### 💡 
<br/>

## 개념 정리

### ⭐ 가상 메모리

* 용어 설명
    * 프레임(Frame): 물리 메모리를 사용하는 최소 크기 단위.
    * 페이지(Page): 가상 메모리를 사용하는 최소 크기 단위.

#### 가상메모리란 무엇인가?
* 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법
* 프로세스의 모든 코드는 항상 필요한 것이 아니다. 오류 처리하는 부분이나 필요 없는 배열 부분은 실제로 프로세스가 잘 동작한다면 필요 없는 부분이 된다. 따라서 프로세스는 필요한 부분만 메모리에 올림으로써 메인 메모리에 올라가는 프로세스의 크기를 줄인다. 프로세스 이미지를 모두 메모리에 올릴 필요가 없는 것이다. 동적 적재와 비슷한 개념이라고 알 수 있다.<br>
<img src = "https://t1.daumcdn.net/cfile/tistory/272FE1405819E01C24"><br>
▶ 페이지 테이블과 가상메모리의 동작.

#### 가상 메모리 장점
* 프로그램은 물리 메모리 크기에 의해 더 이상 제약받지 않게 된다.
* 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 응답시간은 유지되고, CPU 이용률과 처리율은 높아진다.
* 프로그램을 메모리에 올리고 SWAP하는데 필요한 입출력 횟수가 줄어들기 때문에 프로그램들이 보다 빨리 실행된다.

#### 가상 메모리 역할
* 논리 메모리를 물리 메모리로부터 분리시켜주는 것
* 가상 메모리는 페이지 공유를 토해 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 한다.

#### Paging(페이징)이란?
* 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)

#### 가상 메모리 구현
* Page Fault(페이지 부재)
  * 페이지 폴트란 프로그램이 자신의 주소 공간(가상메모리공간)에는 존재하지만 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말한다.
  * 페이지 폴트가 발생하면, 해당 페이지를 가상 메모리에서 찾아야한다. 이 때 운영체제가 페이지 폴트를 해결하는 과정을 요구 페이징(Demand Paging)이라고 한다. 
  > https://preamtree.tistory.com/21

* 요구 페이징 (Demand Paging)
    * 프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대개 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. 한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.
    * 프로세스 내의 개별 페이지들은 페이저(pager)에 의해 관리된다. 페이저는 **프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로서, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.**

* 페이지 교체
    * 페이지를 backing store에서 가져와 메모리에 올려야 되는데 메모리에 자리가 없는 것이다. 이럴 경우 메인 메모리에 있는 특정 페이지를 내보내야할 필요가 있다. 그 자리에 필요한 다른 페이지를 올려야한다. 이를 페이지 교체라고 한다.<br>
    <img src = "https://t1.daumcdn.net/cfile/tistory/266938385913F71805"><br>

* 페이지 교체 알고리즘
  * FIFO 페이지 교체
    * 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.
    * 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
    * `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.
  * OPT or 최적 페이지 교체(Optimal Page Replacement)
    * 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내려 보내는 알고리즘이다.
  * LRU(Least-Recently-Used) 페이지 교체
    * 최근에 사용하지 않은 페이지를 가장 먼저 내려 보내는 알고리즘이다. 최근에 사용되지 않으면 나중에도 사용되지 않을 것이라는 아이디어로부터 온 것이다.
  * LFU(Least Frequently Used) 페이지 교체
    * 참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.
  * MFU(Most Frequently Used) 페이지 교체 
    * LFU 알고리즘과 반대로, 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다. 참조 횟수가 적은 페이지가 최 근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단이다.
> https://copycode.tistory.com/122?category=740133

#### Cache(캐시) 메모리
* 용어 설명
  * CPU가 요청한 데이터가 캐시에 존재하면 Cache HIT
  * 없어서 메모리에서 가져오는 경우 Cache MISS

* Cache란
  * Main memory와 CPU 사이에 존재하여 자주 쓰는 데이터를 저장한다. 따라서 데이터를 읽기 위해 Main memory에 접근하지 않아도 된다. -> 시간 단축

* Cache 작동 원리
  * `적중율(Hit rate)`을 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용한다. 지역성의 전제조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access 하지 않는다는 특성을 기본으로 한다. 즉, Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.

  * 시간 지역성 (Temporal Reference)
    * 한번 참조된 데이터는 다시 참조될 확률이 높다. 

  * 공간 지역성 (Spatial Reference)
    * 참조된 데이터 주변에 있는 데이터가 다음에 참조될 확률이 높다.

* Cache 구조 및 작동 방식 
  * Direct Mapped Cache
      * 메모리 주소의 index field를 기준으로 캐시 메모리에 Mapping 간단하고 빠르지만 Conflict Miss가 발생한다는 단점이 있다.
    <br><img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjgrUD%2FbtqJMxnd8La%2FhiPLn43qhk5bn2o4RvVyDk%2Fimg.png"><br>
  * Fully Associative Cache
      * 비어있는 캐시 메모리 아무 공간에 저장 원하는 데이터를 찾기 위해 cache set을 모두 확인해봐야 하므로 시간이 꽤 걸린다.

  * Set Associative Cache
      * Direct + Fully 방식으로 특정  set을 정해놓고 ( Cache line을 묶은 것이 Cache set )  그 중 비어있는 곳 아무곳에나 저장한다.
