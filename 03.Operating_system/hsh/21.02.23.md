# 21.02.23

## 주요 질문

#### 💡 Kernel(커널)이란?
  * 커널은 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하여 응용 프로그램이 하드웨어에서부터 오는 자원을 관리하고 사용 할 수 있게 해줍니다.

#### 💡 Register(레지스터)란?
  * 레지스터는 CPU(Central Processing Unit)가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치입니다.

#### 💡 CISC(Complex)와 RISC(Reduced)의 차이
  * CISC는 RISC에 비해 연산에 처리되는 복잡한 명령어들을 탑재하고 있기 때문에 전력소모가 크고 속도가 느리다. 다만, RISC는 CISC에 비해 하드웨어가 간단한 대신 소프트웨어가 복잡해 질 수 있습니다.

#### 💡 커널 모드와 유저 모드를 구분해 놓은 이유
  * 시스템에 중요한 영향을 미치는 연산은 커널 모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하는 것입니다. 

#### 💡 System Call(시스템콜)이란?
  * 커널영역의 기능을 사용자모드가 접근하게 도와주는 기능을 System call이라고 부릅니다.
  * 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스입니다.

#### 💡 프로세스간 통신 방법에 대해 설명하시오.
  * 프로세스 간의 데이터와 정보 교환은 커널이 제공하는 IPC를 통해 이루어집니다.
  * IPC에는 Shared memory와 Message passing의 기법이 있습니다.
    * Shared memory는 2개 이상의 프로세스가 같은 메모리 공간을 사용함으로써 데이터를 통신하는 방법입니다.
    * Message Passing 기법은 운영체제가 제공하는 메세지 패싱 방법을 통해 송수신을 통하여데이터를 통신하는 방법 입니다.

#### 💡 Interrupt(인터럽트)란?
  * CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말합니다.
  * 인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉩니다.
    * 하드웨어 인터럽트는 하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생시킨다.
    * 소프트웨어 인터럽트는 외부가 아닌 CPU 내부에서 자신이 실행한 명령이나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생합니다. 


## 개념 정리

### ⭐ 커널이란?
  * 운영체제의 핵심 부분으로서, 운영체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러가지 서비스를 제공한다.
    * 프로세스 관리 ⇒ 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공
    * 메모리 관리 ⇒ 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공
    * 파일 시스템 관리 ⇒ 데이터를 저장하고 접근할 수 있는 인터페이스를 제공
    * 입출력 관리 ⇒ 필요한 입력과 출력 서비스를 제공
    * 프로세스 간 통신 관리 ⇒ 공동 작업을 위한 각 프로세스 간 통신 환경을 **지원**
> https://ddaaadd.tistory.com/261

### ⭐ 리눅스 부팅 과정
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F9973F4465C93931F253F79">

> https://wogh8732.tistory.com/72

#### 1단계 : ROM에 탑재된 BIOS가 키보드/스크린 등의 부팅에 필요한 하드웨어 초기화
  * 첫번째 단계는 ROM에 탑재된 `BIOS`가 키보드나 스크린의 부팅에 필요에 필요한 하드웨어의 각 장치들을 인식하고 초기화 하는 단계이다. 
    * `바이오스(BIOS; Basic Input/Output System)`는 운영 체제 중 가장 기본적인 컴퓨터의 입출력을 처리하는 소프트웨어이다. 사용자가 컴퓨터를 켜면 시작되는 프로그램으로 주변 장치와 컴퓨터 운영 체제 사이의 데이터의 흐름을 관리한다. 

#### 2단계 : 하드디스크 Master Boot Record(MBS)에서 부트로더를 로드해서 실행
  * `Master Boot Record`란 운영체제가 어디에 어떻게 위치해 있는지를 식별하여 컴퓨터의 주기억장치에 적재될 수 있도록 하기 위한 정보가 담겨져있다. 또한 설치된 OS를 실행시키는 부트로더가 포함되어 있다.

#### 3단계 : 부트로더는 커널과 Initial RAM Disk를 메모리에 로드
  * 2단계 후에 MBR에 포함되어 있는 `부트로더`가 램 상에 올라가서 수행을 하게 된다. 
    * 여기서 `부트로더`란  운영체제의 커널이 디스크의 어디에 있는지 알고 있으며 그것을 메모리로 불러오는 역할을 하는 장치 라고 보면 된다. 
      * 쉽게 말하자면 해당 MBR에서 식별한 운영체제의 실질적인 수행을 하는 역할이 바로 부트로더이다.
      * 리눅스에서 가장 많이 사용하는 부트로더로는 `GRUB`가 있는데 처음 리눅스가 개발 될 당시 사용하던 LILO라는 부트로더에서 단점을 보안하여 개발된 것이 바로 `GRUB`이다.

#### 4단계 : - init RAM Disk는 메모리상의 가상의 디스크로 initramfs를 갖는다. -  initramfs는 커널이 초기에 동작하기 위한 기본 드라이버 프로그램들을 가지고 있다.
  * init RAM Disk는 메모리상의 가상의 디스크로써 initramfs이란 파일 시스템을 가지고 있다. 이 파일 시스템에는 커널이 초기에 동작할때 필요한 드라이버나 프로그램, 바이너리 파일 등을 가지고 있다.
  * 즉 부트로더가 커널 이미지를 로딩하면 로딩된 그 커널이 프로그램이나 드라이버를 RAM상에 가상의 디스크형태로 만들어 넣게 된다.

#### 5단계 : 커널의 초기화가 끝나면, /sbin/init 프로그램이 동작하여, 기본 서비스(시간설정, 네트워크 설정 등)를 동작시킨다.
  * 이렇게 커널이 initramfs 파일시스템을 이용하여 초기화 과정을 끝마치면 커널은 이제 수행의 권한을 `/sbin/init` 프로세스에게 넘겨주게 된다. **이 프로세스는 여러가지 기본 서비스들을 동작시키게 한다.** (시간이나 네트워크 웹 서버 등등)
    * init 명령이 시작되면 이는 시스템에서 자동으로 시작하는 모든 프로세스의 부모가 된다. 
    * 먼저 init 명령은 /etc/rc.d/에 있는 스크립트들을 실행하여 패스 설정, 파일 시스템 확인, 시스템 초기화 등에 필요한 동작을 실행한다. 
    * 이러한 조상 프로세스인 init으로 인하 자식 프로세스들 , /etc 밑에 있는 수행에 필요한 프로세스들이 실행되고 모든 동작이 끝나게 되면 드디어 로그인 창이 뜸으로써 부팅과정이 끝나게 된다.

### ⭐ Register(레지스터)란?
* 레지스터는 CPU(Central Processing Unit)가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치이다.
* 실제로 컴퓨터에서 데이터를 영구적으로 저장하기 위해서는 하드디스크를 이용해야 하고, 임시적으로 저장하는 장소를 메모리(RAM)이라고 알고 있을 것이다. 하지만, **메모리로 연산의 결과를 보내고 영구적으로 저장할 데이터를 하드디스크에 저장해야 하는 등의 명령을 처리하기 위해서는 이들에 대한 주소와 명령의 종류를 저장할 수 있는 기억 공간이 하나 더 필요하다. 그리고 이 공간은 무리 없이 명령을 수행하기 위해 메모리보다 빨라야 한다.** 바로 이런 역할들을 하는 것이 CPU옆에 붙어있는 레지스터이다.
> http://itnovice1.blogspot.com/2019/08/blog-post_99.html

### ⭐ CISC and RISC
* 중앙처리장치(CPU)는 두가지가 있음 -> RISC, CISC
* CISC의 단점을 보완하기 위해서 RISC가 나옴
#### CISC (Complex Instruction Set Computer)
  * 연산에 처리되는 복잡한 명령어들을 수백 개 이상 탑재하고 있는 프로세서
  * RISC 프로세서에 비해 전력 소모가 많으며 처리 속도가 느림

#### RISC (Reduced Instruction Set Computer)
  * 복잡한 80% 명령어를 제거하여 사용빈도가 높은 명령어 위주로 20%의 명령어를 H/W화하여 처리속도를 향상시킨 프로세서 
  * 컴퓨터의 실행속도를 높이기 위해 복잡한 처리는 소프트웨어에게 맡기는 방법을 채택하여, 명령세트를 축소한 컴퓨터 
  * CISC에 비해 상대적으로 많은 범용 레지스터를 사용 -> 주기억장치에서 레지스터로 가져와서 처리 -> 빠름

### ⭐ 커널 레벨(Kernel Level) 쓰레드와 유저 레벨(User Level) 쓰레드
#### 커널 모드와 유저모드 
  - 메모리 영역은 사용자에 의해서 할당되는 메모리 공간인 유저 영역과 운영체제라는
하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간인 커널 영역으로 나뉜다.
  - 커널 모드와 유저 모드의 차이는 유저 모드에서 동작할 때 커널 영역으로의 접근이 금지된다.
커널 모드일 때는 모든 영역의 접근이 허용된다.
####  사용자 레벨 스레드
  - 사용자 영역에서 스레드 연산을 수행한다. 
  - 사용자 영역에서 스레드 연산을 수행하기 때문에 운영체제에 투명하다. 
  - `커널에 의존적이지 않은 형태`로 스레드의 기능을 제공하는 라이브러리를 활용하는 방식이 사용자 레벨(User Level) 스레드다.
  - 장점
    - 운영체제에서 스레드를 지원할 필요가 없다. 
    - 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 인터럽트가 발생할 때 커널 레벨 스레드보다 오버헤드가 적다.
    - 즉, 위의 말은 사용자 영역 스레드에서 행동을 하기에 OS Scheduler의 context switch가 없다(유저레벨 스레드 스케줄러를 이용).
    - 커널은 사용자 레벨 스레드의 존재조차 모르기 때문에 모드 간의 전환이 없고 성능 이득이 발생한다.
  - 단점
    - 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다. (무슨 스레드가 먼저 동작할 지 모른다.)
    - 프로세스에 속한 스레드 중 I/O 작업등에 의해 하나라도 블록이 걸린다면 전체 스레드가 블록된다.

### ⭐ 커널 레벨 스레드
  - 커널 스레드는 가장 가벼운 커널 스케쥴링 단위다. 
  - 하나의 프로세스는 적어도 하나의 커널 스레드를 가지게 된다. 
  - 커널 영역에서 스레드 연산을 수행하게 된다.
  - `커널이 스레드를 관리하기` 때문에 커널에 종속적이다.
  - 프로그래머 요청에 따라 스레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨(Kernel Level) 스레드라고 한다.
  - 
  - 장점
    - 프로세스의 스레드들을 몇몇 프로세서에 한꺼번에 디스패치 할 수 있기 때문에 멀티프로세서 환경에서 매우 빠르게 동작한다.
    - 다른 스레드가 입출력 작업이 다 끝날 때까지 다른 스레드를 사용해 다른 작업을 진행할 수 있다. 
    - 커널이 각 스레드를 개별적으로 관리할 수 있다. 
    - 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.
  
  - 단점
    - 스케줄링과 동기화를 위해 커널을 호출하는데 무겁고 오래걸린다.(저장한 내용을 다시 불러오는 과정이 필요)
    - 즉, 사용자 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생한다.
    - 사용자가 프로그래밍할 때 구현하기 어렵고 자원을 더 많이 소비하는 경향이 있다
  
> https://junghyun100.github.io/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%88%98%EC%A4%80ThreadVS%EC%BB%A4%EB%84%90%EC%88%98%EC%A4%80Thread/

> https://www.crocus.co.kr/1255

### ⭐ 시스템콜 
  * 커널영역의 기능을 사용자모드가 접근하게 도와주는 기능을 System call이라고 부릅니다.
  * 시스템 콜(system call), 간단히 시스콜(syscall)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.
  * 시스템 콜의 기능
    * 프로세스 제어
      * e.g. exec() : 다른 프로그램의 실행, fork() : 새 프로세스의 생성
    * 파일 조작
      * e.g. open(), read(), write() 등
    * 정보 유지
      * 시간, 날짜의 설정 등
    * 통신
      * 공유 메모리에서 다른 프로세스 소유 메모리 접근 시

### IPC(Inter-Process Communication, IPC) - 프로세스 간 통신
* 프로세스 간의 데이터와 정보 교환은 커널이 제공하는 IPC를 통해 이루어진다.
* IPC에는 Shared memory와 Message passing의 기법이 있다.

#### Shared memory
* shared-memory 공간은 2개 이상의 프로세스가 함께 공유할 수 있으며, 이 공간은 데이터가 어떤 모양인지, 어느 위치에 저장되는지 OS가 관여하지 않는다. 즉, 프로세스들끼리 규약을 정하고, 알아서 사용한다.

* 장점
  * 빠르다. (Suitable for large amout of data)
* 단점
  * 규약을 잘 정해야 한다. 공유된 메모리 공간에 동시에 writing하면 안된다. 즉, 정보를 어떻게 교환할 것인지에 대한 약속이 잘 이루어져야 한다. -> Producer-Consumer Problem
    * 대부분 Bounded buffer를 사용한다.
이는 버퍼가 가득 차 있는 경우는 Consumer가 Shared Memory에서 정보를 가져가 빈 공간이 생길때까지 Producer가 기다려야 한다. 버퍼가 비어있는 경우는 Consumer가 Producer를 기다리게 된다.

#### Message-Passing Systems
* OS가 제공하는 Message-passing을 이용한 프로세스 커뮤니케이션으로, 교환되는 메세지를 이용하여 통신하므로 공유되는 메모리 영역이 필요하지 않다.

* 장점
  * No conflict: os kernel이 관여하기 때문에 conflict가 발생하지 않는다. (Suitable for smaller amout of data)
  * 다른 컴퓨터에도 메시지 패싱을 통해 데이터를 전달할 수 있다.
* 단점
  * 큰 데이터를 전달하기 힘들며, 시스템 콜을 통해 구현되므로 상대적으로 느리다.

> https://velog.io/@chy0428/OS-IPC-systems

### ⭐ Interrupt - 인터럽트
* CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.
* 주변장치와 입출력 장치는 CPU나 메모리와 달리 `인터럽트라`는 메커니즘을 통해 관리된다.
* 인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.

#### 하드웨어 인터럽트 (외부 + 내부 인터럽트)
* 하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생시킨다.
  - 정전 또는 전원 공급의 이상 
  - CPU 또는 기타 하드웨어의 오류
  - 타이머 인터럽트
  - 하드웨어 입출력 장치

#### 소프트웨어 인터럽트
* 소프트웨어가 발생시키는 인터럽트이다. 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다.
  - 허가되지 않은 메모리 주소 참조
  - 0으로 나누는 경우
  - 시스템 콜
  - 페이지 부재

> https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8

> https://jhnyang.tistory.com/167