
# 21.01.14

  

## 주요 질문

  
#### 💡 [정규화란?](#-정규화)

* 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정이 정규화이다. 일반적으로 테이블을 여러 개로 분해하면 속도는 상대적으로 느려 질 수 있지만, 분해하지 않으면 삽입 , 삭제, 갱신 시 이상 문제들이 발생 합니다. 정규화는 총 6단계가 있지만 대체로 1~3 정규화 과정을 거칩니다. <U>(릴레이션 분해로 인한 속도 저하)</U>

   -	저장 공간 최소화
   -	자료 구조 안정화
   -	자료 삽입, 삭제, 갱신 시 이상 현상 방지

#### 💡 정규화 과정에 대해 설명하시오.
      제1정규형 (원자값이 아닌 도메인 분해)
      제2정규형 (부분 함수 종속 제거)
      제3정규형 (이행 함수 종속 제거)
      BCNF (결정자가 후보키가 아닌 함수 종속 제거)
      제4정규형 (다치 종속 제거)
      제5정규형 (후보키를 통하지 않는 조인 종속의 제거)

#### 💡 정규화와 반정규화의 차이
 * .

#### 💡 관계형 데이터베이스의 특징
 * 관계형 데이터베이스의 특징은 다음과 같습니다. 
    1. 데이터의 분류, 정렬, 탐색 속도가 빠릅니다.
    2. 오랫동안 사용된 만큼 신뢰성이 높고, 어떤 상황에서도 데이터의 무결성을 보장해 줍니다.
    3. 기존에 작성된 스키마를 수정하기가 어렵습니다.
    4. 데이터베이스의 부하를 분석하는 것이 어렵습니다.


#### 💡 무결성 제약조건이란?
 * 테이블에 부적절한 자료가 입력 되는 것을 방지하기 위해서 테이블을 생성할 때 각 컬럼에 대해서 정의하는 여러가지 규칙을 말한다. 개체, 참조, 도메인 등의 제약조건이 존재한다.


#### 💡 [키의 종류와 그에 대해 설명하시오.](#-key-종류)
 * 키(Key)는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 Attribute(속성)입니다. 기본키, 대체키, 슈퍼키, 후보키, 외래키로 구분 됩니다.
   ![key](./img/database_key.jpg)







<br/>

## 심화 질문

<!-- #### 💡 Database를 사용하는 이유

* 파일처리시스템의 문제점을 해결하기 위한 목적으로 만들어졌다. 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다. -->
  
<br/>

## 개념 정리

### ⭐ 정규화

* Normalization Process
  <p><img src="https://lh5.googleusercontent.com/X2JVceWxlv6riqnnuW1HkvLWiN3HZCvnnqZF72wa6wFPRqbIgBtP6HTnu9qScwKM2PGRdV1Vy5BpE3Pr7CI_4R0qx9YNOqBU95KjcPJNN7fh3EKctifnlhIUzzZqd8PnNM_oKKAe"></p>

 * 함수적 종속이란?
   함수적 종속은 어떠한 릴레이션에서 속성들의 부분 집합을 X, Y라 할 때 특정 튜플에서 X의 값이 Y의 값을 함수적으로 결정 한다면 Y가 X에 함수적으로 종속 되었다고 합니다.


   <details  markdown="1">

   <summary>출처</summary>

   <!--summary 아래 빈칸 공백 두고 내용을 적는공간-->

   https://nirsa.tistory.com/107 <br/>
   https://wkdtjsgur100.github.io/database-normalization/


   </details>
<br/>


### ⭐ 무결성 제약조건 종류
  1. 개체 무결성
     * 릴레이션에서 기본키를 구성하는 속성은 널(NULL)값이나 중복값을 가질 수 없습니다.
     ex) <학생> 릴레이션에서 '학번'이 기본키로 정의되면 튜플을 추가할 때 '주민번호'나 '성명'필드에는 값을 입력하지 않아도 되지만 '학번' 속성에는 반드시 값을 입력해야 합니다. 또한 '학번' 속성에는 이미 한번 입력한 속성값을 중복하여 입력 할 수 없습니다.
     즉 NULL 값 허용 불가, 값 중복 허용 불가 입니다.

  2. 참조 무결성
     * 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 합니다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없습니다. 
     당연한 이야기입니다. 없는 값을 참조할 수 없으니 있는 값에서 참조하라는 말입니다.
   
      * _ex) <수강> 릴레이션 '학번' 속성에는 <학생> 릴레이션의 '학번' 속성에 없는 값은 입력할 수 없습니다._

  1. 도메인 무결성
     * 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정입니다. 현재 대한민국 고등학교 학년은 1학년,2학년,3학년이지요? 그렇다면 학년이라는 속성값에 들어갈 수 있는 값의 범위는 무조건 1~3입니다. 이것이 바로 도메인 무결성입니다. 또 한가지 예를 들어 보겠습니다. 인간의 성별은 남, 여로 나뉩니다. 그렇다면 성별이라는 속성에 들어 갈 수 있는 값은 여자 이거나 남자 여야 합니다. 남자, 여자 이외의 값은 도메인 무결성을 위반한 것이라 할 수 있습니다. 
   
  2. 고유 무결성
      * 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건을 말합니다.  학생 릴레이션(테이블)에서 테이블 정의시 '이름' 속성에는 중복된 값이 없도록 제한했다면, '이름' 속성에는 중복된 이름이 있어서는 안됩니다.

  3. NULL 무결성
      * 특정 속성값에 NULL 이 올 수 없다는 조건이 주어진 경우, 그 속성값은 NULL 값이 올 수 없다는 제약조건을 말합니다. 학생 릴레이션에서 릴레이션 정의 시 '학과' 속성에는 NULL 값이 올 수 없도록 제한했다면 '학과' 속성에는 NULL 이 있어서는 안됩니다.

  4. 키 무결성
      * 한 릴레이션(테이블)에는 최소한 하나의 키가 존재해야 한다는 제약조건을 뜻합니다.


<br>

### ⭐ Key 종류
  1. 후보키 (Candidate Key)
     * 릴레이션을 구성하는 속성들 중 튜플을 유일하게 식별할 수 있는 속성들의 부분집합을 의미합니다. 

         _ex) <학생> 릴레이션에서 '학번'이나 '주민번호'는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키가 될 수 있습니다. 즉 기본키가 될 수 있는 키들을 후보키라고 합니다._

  1. 기본키 (Primary Key)
     * 후보키 중에서 선택한 주키(Main Key)
     * 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성

         _ex) <학생> 릴레이션에는 '학번'이나 '주민번호'가 기본키가 될 수 있고, <수강> 릴레이션에는 '학번'+'과목명'으로 조합해야 기본키가 만들어 질 수 있습니다. 왜냐면 <수강> 릴레이션에서는 '학번' 속성과 '과목명' 속성은 개별적으로 기본키로 사용할 수 없습니다. 다른 튜플들과 구별되지 않기 때문이지요._

         _ex) <학생> 릴레이션에서 '학번'을 기본키로 정의되면 이미 입력된 '1001'은 다른 튜플의 '학번' 속성 값으로 입력할 수 없습니다._

  2. 대체키 (Alternate Key)
     * 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말합니다.
     * 보조키라고도 합니다.

         _ex) <학생> 릴레이션에서 '학번'을 기본키로 정의하면 '주민번호'는 대체키가 됩니다._ 

  4. 슈퍼키 (Super Key)
     * 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않습니다. 
     * 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족시키지 못합니다.

         _ex) <학생> 릴레이션에서는 '학번', '주민번호', '학번'+'주민번호', '학번'+'주민번호'+'성명' 등으로 슈퍼키를 구성할 수 있습니다. 또한 여기서 최소성을 만족시키지 못한다는 말은 '학번'+'주민번호'+'성명' 가 슈퍼기인 경우 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만, '성명' 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못합니다. 즉 뭉쳤을 경우 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성있는 키로 사용할 수 없습니다. 이것을 최소성을 만족하지 못한다고 합니다._

5. 외래키 (Foreign Key)
   * 관계(Relation)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성
   * 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구로 사용됩니다.
   * 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없습니다. (참조 무결성 조건)
      
      _ex) <수강> 릴레이션이 <학생> 릴레이션을 참조하고 있으므로 <학생> 릴레이션의 '학번'은 기본키이고, <수강> 릴레이션의 '학번'은 외래키입니다. 즉 각 릴레이션의 입장에서 속성은 기본키가 되기도하고, 외래키가 되기도 합니다._

      _ex) <수강> 릴레이션의 '학번'에는 <학생> 릴레이션의 '학번'에 없는 값은 입력할 수 없습니다._

<br>

### ⭐ RDBS 용어 정리
   ![key](./img/database2.png)
     
   1. 열(column)<br/>
    각각의 열은 유일한 이름을 가지고 있으며, 자신만의 타입을 가지고 있습니다. 또한 열의 개수를 차수라고 표현하고, 이러한 열은 필드(field) 또는 속성(attribute)이라고도 불립니다.
       
   2. 행(row)<br/>
   행은 관계된 데이터의 묶음을 의미합니다.
   한 테이블의 모든 행은 같은 수의 열을 가지고 있습니다.
   이러한 행은 튜플(tuple) 또는 레코드(record)라고도 불립니다.
    
   3. 값(value)<br/>
   테이블은 각각의 행과 열에 대응하는 값을 가지고 있습니다.
   이러한 값은 열의 타입에 맞는 값이어야 합니다.
    
   4. 키(key)<br/>
   테이블에서 행의 식별자로 이용되는 열을 키(key) 또는 기본 키(primary key)라고 합니다.
   즉, 테이블에 저장된 레코드를 고유하게 식별하는 후보 키(candidate key) 중에서 데이터베이스 설계자가 지정한 속성을 의미합니다.
    
   5. 관계(relationship)<br/>
   테이블 간의 관계는 관계를 맺는 테이블의 수에 따라 다음과 같이 나눌 수 있습니다.
    

   6. 스키마(schema)<br/>
   스키마는 테이블을 디자인하기 위한 청사진이라고 할 수 있습니다. 이러한 스키마는 테이블의 각 열에 대한 항목과 타입뿐만 아니라 기본 키와 외래 키도 나타내야 합니다.

   7. 도메인(domain)<br/>
   도메인은 어트리뷰트가 취할 수 있는 모든 원자값의 범위 (표현되는 속성값의 범위)


### ⭐ 관계 대수 정리
   * 릴레이션 간의 연산으로 새로운 릴레이션을 만들어내는 과정
   원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 방법 (절차식!)

   ##### 집합 연산자
   _____

   * 합집합 (Union)
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMjI2/MDAxNTkxMDI4MjYwMzg4.u-xu1FV8Ta5VehGtYoJagI8V-o1ajwmTzshvA4V23bog.oXVWXMZJsD4wP7juLAvqYNKwmkTd0eKTiFcux3Mi-EUg.PNG.syunjae21/SE-afedfdf9-884e-47c7-af19-0130dc00dc76.png" width="50%" height="50%""></p>
    
   * 교집합 (Intersection)
     <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfNDcg/MDAxNTkxMDI4NTU0NjM0.qJbHIRk2h9BVT6WzBx0mP0-kYHDAFLPi-9fovt6yRKog.7L1zWdSTfGUjwh0znWJ4s0vuRetfQjOts_0ellI_tW0g.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_12_39_28.png" width="50%" height="50%""></p>   

   * 차집합 (Difference)
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfNTEg/MDAxNTkxMDI4NzAzNzg5.Uhoi4Y0Ip4IhgoMKtjIHgnhDUMIGG8us-oI3iQW1_owg.BqNGS6l7d3tRkTc77a556hlYOJNu9buxI3k6qISU_VAg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_12_51_10.png" width="50%" height="50%""></p>

   * 곱집합 (Cartesian Product)
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfNCAg/MDAxNTkxMDI4ODIwNDUz.Np1HrUDhJcy05FMffoQwp3kiIQO66Dx_VWmQGH8pEKsg.Y_P1IjoyuaC0ueGSE3F_nK93I7P0_QlA_6FAXEWcmNUg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_1_11_20.png" width="50%" height="50%""></p>

   * 프로젝션 (Projection)
     - 릴레이션에서 구하고자 하는 속성을 선택하여 분리해 내는 연산
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMTU1/MDAxNTkxMDM4OTYzNDEw.GhnEInxqe9iPzSvwXehDrGfO-bvRlky4bEoCnrWIIO4g.WEodMcFoXPYuLblOKhSpJTg7ANbACO9mPLgLr_FpYGIg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_1_52_30.png" width="50%" height="50%""></p>
    
   * 셀렉션 (selection) 
     - 릴레이션에서 조건에 맞는 레코드(튜플)을 분리해 내는 연산 
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMjk0/MDAxNTkxMDM5MzYyODQ4.zKsJWbRwl8fQ-vx8DAv7_PYwhVHR2m4hV1KK6LtyKtUg.G82k_EaQ6IdLUbgW6tamy8p1CHxRIhCOohV3sXOqt1Ig.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_1_58_45.png" width="50%" height="50%""></p>
   

   ##### 조인 연산자
   ____

   * 세타 조인
     - 두 개의 릴레이션에서 조건에 맞는 속성이 들어있는 튜플을 접속[Concatenation]하여 새로운 릴레이션을 생성하는 연산
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfNzEg/MDAxNTkxMDM5ODQ0NzAw.2No4YQa67cuIUzIf7uI4Lj-cvqTYODDADk-MYpPHNPgg.xJAq81VuyTaIWaTH-o4rnaJTWLuzv0PtyS8-lkrRRj8g.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_2_11_53.png" width="50%" height="50%""></p>
   * 동일 조인
     -  세타 조건식에 의한 조인 중 조건식이 같은 경우의 조인을 의미한다.
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMjc3/MDAxNTkxMDM5OTA5Mjg1.FGsw0MczoQWMgnhYXqLrz3W8i7FOCcB2SUF5TCkCTzEg.1AGUeV3FFcV4ofxunIGCWw3TJq5w7izzuGCzMxHleJsg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_2_27_53.png" width="50%" height="50%""></p>
   * 자연 조인 (natural)
     - 두 릴레이션의 속성값 모두를 대상으로 동일 조인을 한 후 나타나는 중복 속성을 한 쪽 릴레이션에서 제거하고 나타낸 것
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMjI2/MDAxNTkxMDI4MjYwMzg4.u-xu1FV8Ta5VehGtYoJagI8V-o1ajwmTzshvA4V23bog.oXVWXMZJsD4wP7juLAvqYNKwmkTd0eKTiFcux3Mi-EUg.PNG.syunjae21/ SE-afedfdf9-884e-47c7-af19-0130dc00dc76.png](https://blogfiles.pstatic.net/MjAyMDA2MDJfMjM5/MDAxNTkxMDQwMDE4MzA4.ix4TqaYBAjP1nlwbqMxE0ndHWvFOx9wi9fLWAElqdzUg.PgHMrGCW9uSW4SIgkFTDbZi705Z6HOhIvLSPP8VNmKIg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_3_12_21.png)" width="50%" height="50%""></p>
   * 세미 조인
     - 자연 조인한 결과 릴레이션을 조인에 참여한 두 릴레이션 중 하나의 속성 형태로 프로젝션하는 연산
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMjY4/MDAxNTkxMDQwMDYxNTQ0.jwdVG9zuFJPuoXD8fxkvK4SvOvsU3wk4Cx42kXaWb_Yg.JIjYj_rz6jUkfGbRg7a3PNEAqiFGHzGIuKXC4iwonUog.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_3_26_50.png" width="50%" height="50%""></p>
   * 외부 조인 (outer)
     - 두 개의 릴레이션을 자연 조인할 때 조인할 상대 릴레이션에 대응되는 튜플이 존재하지 않는 경우 이를 배제하지 않고 널[NULL] 튜브로 만들어 결과 릴레이션에 포함시키는 조인 방식
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfMjA3/MDAxNTkxMDQwMDkzNDE1.LyZf8lJVlqQeXq6qNx_o2cTYE4NJkUOISWUiRYG2N0Yg.jKru7MM3jc3L0-C558W0--XfpkWAMipkT_odWgsvdswg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_3_42_00.png" width="50%" height="50%""></p>
   
    
   * 디비전 (Division)
     - 두 개의 릴레이션 R, K가 있을 때, K 릴레이션의 모든 조건을 만족하는 경우의 튜플들을 릴레이션 R에서 분리해 내어 프로젝션하는 연산
      <p><img src="https://blogfiles.pstatic.net/MjAyMDA2MDJfNzQg/MDAxNTkxMDQwMzAyMDQx.WoMgUw540Hf4ty-YTrpNzIVZ-yOC1b1nlhHmZLq8W7Eg.-aVhg06fdmDDO8E8B8j1DPTh12O9JAPy46J4vB8QA6Yg.PNG.syunjae21/%ED%8C%8C%EC%9D%BC_2020._6._2._%EC%98%A4%EC%A0%84_4_05_17.png" width="50%" height="50%""></p>

 
 

  