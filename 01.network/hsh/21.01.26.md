# 21.01.26

## 주요 질문

#### 💡 로드 밸런싱(Load Balancing)에 대해 설명하시오.
   * 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 바로 로드 밸런싱이다.
   * 로드 밸런싱은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식이다. 서비스를 운영하는 사이트의 규모에 따라 웹 서버를 추가로 증설하면서 로드 밸런서로 관리해주면 웹 서버의 부하를 해결할 수 있다.
   <img src = "https://camo.githubusercontent.com/b59f02d63a1372b35abffa94e241b9b8d27447f3/68747470733a2f2f7777772e6564756361746976652e696f2f6170692f636f6c6c656374696f6e2f353636383633393130313431393532302f353634393035303232353334343531322f706167652f353734373937363230373037333238302f696d6167652f353639363435393134383039393538342e706e67">
   * 로드 밸런서가 서버를 선택하는 방식
     1. 라운드 로빈(Round Robin) : CPU 스케줄링의 라운드 로빈 방식 활용
     2. Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)
     3. Source : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)

     
#### 💡 [Blcoking vs Non-Blocking model](#corscross-origin-resource-sharing)
   * Blocking model은 I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식이다. Non-Blocking model은 blocking 방식의 비효율성을 극복하고자 도입된 방식이다. I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식이다.

#### 💡 [CORS(Cross Origin Resource Sharing)가 왜 필요한가요?](#corscross-origin-resource-sharing)
   * 만약 내가 서비스하고 있지 않은 사이트에서 세션을 요청해서 세션을 획득할 수 있다면 해당 사이트는 악의적으로 내 세션을 탈취하거나 다른 행동을 할 수 있습니다. 그래서 브라우저에서는 이러한 요청을 막습니다. 피싱사이트가 대표적인 공격 사례인데 이러한 것을 막고 내가 허용한 origin들만 요청할 수 있도록 하기 위해 필요합니다.

## 개념 정리

### Blcoking,Non-Blocking

   * I/O 작업
      - 먼저 I/O 용어는 Input/Output의 약자로 알고 있을 것이다. 주로 파일 입출력을 다룰 때 흔히 볼 수 있다. 네트워크에서도 쉽게 볼 수 있는데 예를 들어, 소켓의 read/send를 생각하면 이해가 갈 것이다.

      - 두 대 이상의 컴퓨터끼리 서로 네트워크를 통해 통신을 한다고 가정할 때,
      한 컴퓨터에서 출력(send)을 하고, 다른 한 컴퓨터에서 입력(read)을 받는 과정을 통해 통신을 할 수 있다.

      - I/O 작업은 User(유저 레벨)에서 직접 수행할 수 없고, 실제 IO 작업을 수행하는 것은 Kernel(커널 레벨)에서만 가능하다.
      유저 프로세스(또는 스레드)는 커널에게 요청을 하고 작업 완료 후 커널이 반환하는 결과를 기다릴 뿐이다.

   * Blocking Model
      - 가장 기본적인 I/O 모델로, linux에서 모든 소켓 통신은 기본 blocking으로 동작한다. I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식이다.
      <img src ="https://user-images.githubusercontent.com/41428527/51266321-4ade9700-19fe-11e9-9b23-30bca4faccfd.png">
      * 위의 그림처럼 유저는 커널에게(유저->커널) read작업을 요청하고 데이터가 입력될 때까지 대기하다가 데이터가 입력되면 유저에게(커널->유저) 결과가 전달되어야만 유저 자신의 작업에 비로소 복귀할 수 있다.

      * 말 그대로 block이 되고, 어플리케이션에서 다른 작업을 수행하지 못하고 대기하게 되므로 자원이 낭비된다.

   * Non-Blocking Model
     * 위와 같은 blocking 방식의 비효율성을 극복하고자 도입된 방식이다. I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식이다.
     <img src = "https://user-images.githubusercontent.com/41428527/51266324-4e721e00-19fe-11e9-900a-809ff39e40c1.png">
        1. 유저가 커널에게 (유저->커널) read작업을 요청하면
        2. 데이터가 입력이 됬든 안됬든 요청하는 그 순간, 바로 결과가 반환된다.이 때, 입력 데이터가 없으면 입력 데이터가 없다는 결과 메세지(EWOULDBLOCK)를 반환한다.
        3. 입력 데이터가 있을 때 까지 1-2번 반복. (2번에서 결과 메세지를 받은 유저는 다른 작업 진행이 가능하다.)
        4. 입력 데이터가 있으면 유저에게(커널->유저) 결과가 전달된다.
      * 이 경우 I/O의 진행시간과 관계가 없기 때문에(대기x) 어플리케이션에서 작업을 오랜 시간 중지하지 않고도 I/O 작업을 진행할 수 있다. 그러나 반복적으로 시스템 호출이 발생하기 때문에 이 경우 역시 자원이 낭비된다.

 ### CORS(Cross Origin Resource Sharing)
   * Cross-Origin Resource Sharing(CORS)은 추가적인 HTTP header를 사용해서 애플리케이션이 다른 origin의 리소스에 접근할 수 있도록 하는 메커니즘을 말합니다. 하지만 다른 origin에서 내 리소스에 함부로 접근하지 못하게 하기 위해 사용된다.

   * 브라우저가 리소스를 요청할 때 추가적인 헤더에 정보를 담습니다. 내 origin은 무엇이고 어떤 메소드를 사용해서 요청을 할 것이고 어떤 헤더들을 포함할 것인지를 담아서 서버에 전송합니다. 서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 보냅니다. 브라우저가 이 헤더를 보고 해당 origin에서 요청할 수 있다면 리소스 전송을 허용하고 만약 불가능하다면 에러를 발생시킵니다.
   ```
   Origin이란?
      - 도메인(domain): naver.com
      - 오리진(origin): https://www.naver.com/PORT
      - 이와 같이 도메인과 오리진의 차이는 프로토콜과 포트번호의 포함 여부이다.
   ```