# 21.01.16 HTTP & HTTPS

## 주요 질문

#### 💡 HTTP 프로토콜을 설명해주세요.

* Hyper Text Transfer Protocol의 약자로 인터넷에서 데이터를 주고 받을 수 있는 프로토콜입니다. 


#### 💡 HTTPS 프로토콜을 설명해주세요.

* HTTPS는 HTTP에 S(Secure Socket)을 추가한 것입니다. 데이터를 주고받는 과정에 보안 요소가 추가됩니다. 

* 클라이언트는 공개키로 데이터를 암호화해서 전송하고 서버는 개인키를 이용해 복호화 합니다.

* 서버는 개인키로 데이터를 암호화해서 전송하고 공개키가 있는 클라이언트에서 데이터를 복호화 합니다.

#### 💡 [HTTP의 단점을 설명해주세요.](#TCP/IP는-도청-가능한-네트워크이다.)

* 평문 통신(암호화 되지 않은 통신)이기 때문에 도청이 가능합니다.
* 통신 상대를 확인하지 않아 위장이 가능합니다.
* 완전성을 증명할 수 없기 때문에 변조가 가능합니다.

#### 💡  HTTP REQUEST 방식 중 GET과 POST의 차이을 설명해주세요.

* GET방식은 정보를 가져와서 조회하기 위한 방식입니다.
url에 데이터를 포함시켜서 서버에 요청하기 때문에 보안에 취약합니다.
주로 즐겨찾기를 편리하게 하기 위해 사용합니다.(CRUD 중 READ)

* POST방식은 데이터를 서버로 보내서 추가하기 위한 방식입니다.
서버로 전달하고자 하는 데이터를 body에 넣어서 전달을 합니다. get방식에 비해 url에 데이터를 노출시키지 않아 보안에 좋습니다.
POST방식은 DB의 내용을 갱신해야하거나 서버로 데이터를 전달해야할 때 쓰는 것이 적합합니다.
(CRUD 중 CREATE)

#### 💡  GET, POST를 제외하고 다른 방식들을 설명해주세요.

* Put은 데이터를 추가하거나 수정할 때 사용합니다.(CRUD 중 CREATE, UPDATE)

* Patch는 데이터 일부분을 수정할 때 사용합니다.(CRUD 중 UPDATE)

* Delete는 정보를 삭제할 때 사용합니다.(CRUD 중 DELETE)
   
   
#### 💡 HTTP1 vs HTTP2 를 설명해주세요.

* HTTP1은 연결당 하나의 요청과 응답을 처리합니다. 동시전송 문제와 다수의 리소스를 처리하기에 속도와 성능문제가 발생할 수 있습니다.

* HTTP2는 한 커넥션에 여러개의 메시지를 동시에 주고받을 수 있습니다. 문서상 필요한 리소스를 클라이언트의 요청 없이 보내줄 수도 있고, 헤더 정보를 압축하는 것도 가능합니다.
그래서 성능과 속도 면에서 HTTP1보다 뛰어납니다.

   <img src="images/http1_2.png" width="500">


<br/>

## 심화 질문

#### 💡 HTTP는 비연결성 프로토콜이냐? 연결성 프로토콜이냐?

* 비연결성 프로토콜입니다. 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊습니다.

#### 💡 HTTP는 왜 비연결성인가?

* HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었습니다.
만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생하게 됩니다.
따라서 **연결을 유지하기 위한 리소스를 줄이면 더 많은 연결을 할 수 있으므로** 비연결적인 특징을 갖습니다.

* 단점으로는 서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로 연결/해제에 대한 오버헤드가 발생한다는 점이 있습니다.

#### 💡 모든 웹 페이지에서 HTTPS 를 사용하지 않는 이유를 설명해주세요.
* 평문 통신에 비해서 암호화 통신은 CPU 나 메모리 등 리소스가 많이 필요합니다. 통신할 때마다 암호화를 하면 서버 한 대당 처리할 수 있는 요청의 수가 줄어들게 됩니다. 그렇기 때문에 민감한 정보를 다룰 때만 HTTPS 를 사용합니다.


#### 💡 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?
* 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 합니다.(Idempotent, 멱등)
GET 방식은 가져오는 것(Select) 으로, 서버의 데이터나 상태를 변경시키지 않아야 합니다.
Ex) 게시판의 리스트, 게시글 보기 기능
예외) 방문자의 로그 남기기, 글을 읽은 횟수 증가 기능

* POST 방식은 수행하는 것 으로, 서버의 값이나 상태를 바꾸기 위한 용도입니다.
Ex) 게시판에 글쓰기 기능
* 웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 합니다.
어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 합니다.
즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요합니다.
이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야합니다. 그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용합니다.

#### 💡 현대 웹 에서는 비연결성을 해결방법을 설명해주세요.
* 전통적으로 [Cookie](#쿠키)와 [Session](#세션)을 많이 이용합니다. 

* Cookie에 클라이언트에 대한 정보를 저장해뒀다가 사용하거나 Session을 등록해서 유지하는 방식으로 많이 사용합니다. 

* HTML5에서 제공하는 [Session Storage나 Local Storage](#Web-Storage)도 사용할 수 있습니다. 
세션 스토리지는 세션이 유지되고 있을 때 까지는 브라우저 내부 스토리지에 저장을 하고 세션이 끊키면 자동으로 없어집니다. 
로컬 스토리지 같은 경우는 내부적으로 삭제를 하지 않는 이상 영구적으로 저장됩니다.
   

#### 💡 세션과 쿠키를 사용하는 이유를 설명해주세요.
* HTTP는 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있습니다.
* 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 합니다. 웹사이트에서 방문자가 머무르는 동안 방문자의 상태를 유지하기 위해 세션과 쿠키를 사용합니다.


#### 💡 보안성 낮은 쿠키를 쓰는 이유를 설명해주세요.

* 세션을 과도하게 생성하면 서버의 메모리가 과도하게 사용되어 무리가 가기 때문입니다.

#### 💡 세션과 쿠키의 차이점을 설명해주세요.
* 데이터 저장 위치 관점에서 세션은 서버에 저장되고 쿠키는 클라이언트의 로컬 하드드라이브에 저장됩니다.
* 보안 관점에서 세션은 아이디만 쿠키에 저장하기 때문에 보안성이 높습니다. 쿠키는 보안성이 취약합니다.
* 라이프 사이클 관점에서 세션은 브라우저가 종료될 때까지 있습니다. 쿠키는 사용자가 삭제할 때까지 남아있습니다.

#### 💡 Session 동작 순서를 설명해주세요.

1. 웹사이트에 접속합니다.
2. 서버는 세션 ID를 하나 생성해서 쿠키 값으로 만들고 웹 브라우저에 전송합니다.
3. 웹 브라우저는 이 쿠키값을 저장해 두었다가 웹 서버에 무언가 요청할 때마다 쿠키 헤더를 통해서 세션을 보냅니다.
4. 서버는 요청을 받을 때마다 세션 ID를 확인하고 정보가 알맞을 때에만 사용자에게 데이터를 보내줍니다.


#### 💡  Cookie, Session, Session Storage, Local Storage 중 어떤 것이 가장 효율적인가요?



<br/>

## 개념 정리

#### TCP/IP는 도청 가능한 네트워크이다.
* TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.

* 보안 방법
통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP 의 통신 내용을 암호화할 수 있다. SSL 을 조합한 HTTP 를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다.
콘텐츠를 암호화 말 그대로 HTTP 를 사용해서 운반하는 내용인, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.


#### HTTP는 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
* HTTP 에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 리퀘스트를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.

* 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다.
리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다.
통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.
어디에서 누가 리퀘스트 했는지 확인할 수 없다.
의미없는 리퀘스트도 수신한다. —> DoS 공격을 방지할 수 없다.
* 보완 방법
위 암호화 방법으로 언급된 SSL로 상대를 확인할 수 있다. SSL 은 상대를 확인하는 수단으로 증명서 를 제공하고 있다. 증명서는 신뢰할 수 있는 제 3 자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.


#### HTTP는 완전성을 증명할 수 없기 때문에 변조가 가능하다
* 여기서 완전성이란 정보의 정확성 을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.

* 보완 방법
MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 HTTPS를 사용해야 한다. SSL 에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.

#### 쿠키

* 사용자정보를 파일 형태로 클라이언트 로컬에 저장하는 것입니다.
브라우저를 종료해도 사용자의 하드 드라이브에 저장돼서 사라지지 않습니다.
직접 삭제하거나 만료되어야 합니다.

* 보안성이 낮습니다.

* 자동 로그인, 장바구니에 사용됩니다.

* 구성 요소
   * 쿠키의 이름(name)
   * 쿠키의 값(value)
   * 쿠키의 만료시간(Expires)
   * 쿠키를 전송할 도메인 이름(Domain)
   * 쿠키를 전송할 경로(Path)
   * 보안 연결 여부(Secure)
   * HttpOnly 여부(HttpOnly)

* 동작 방식

   <img src="images/cookie.png" width="400">

   1. 웹브라우저가 서버에 요청
   2. 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성
   3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송
   Set−Cookie: id=doy
   4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송
   cookie: id=doy
   5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답

#### 세션
   * 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술입니다.
   * 세션은 방문자가 웹에 접속하는 시점에 생기고 웹을 종료하는 시점에 삭제됩니다.
세션 아이디는 쿠키로 전달됩니다.

<img src="images/session-process.png" width="550">

   * 동작 방식
      1. 웹브라우저가 서버에 요청
      2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함
      3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송
      4. 쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장
      Set−Cookie: JSESSIONID=xslei13f
      5. 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송
      Cookie: JSESSIONID=xslei13f
      6. 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답


#### Web Storage
   * 키, 값의 쌍으로 데이터를 저장하고 키를 기반으로 데이터를 조회하는 방식입니다.
   영구저장소(local storage)와 임시 저장소(session storage)를 따로 두어 환경에 맞게 선택할 수 있습니다.


#### Local Storage
   * 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능합니다. 도메인마다 로컬 스토리지가 생성됩니다. 


#### Session storage
   * windows 전역 객체의 sessionStorage라는 컬렉션을 통해 저장과 조회가 이루어집니다.

<br/>
