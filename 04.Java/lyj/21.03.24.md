## 가비지 컬렉션과 가비지 컬렉터

### **가비지(Garbage)의 의미**

- 시스템에서 더 이상 사용하지 않는 메모리

### **가비지 컬렉션(Garbage Collection)**

어떤 데이터를 동적으로 메모리에 할당하여 저장을 한 후 더 이상 필요하지 않을 때, 즉 어떠한 참조변수도 해당 메모리 영역을 가르키지 않을때 메모리를 재사용하기 위해 해당 데이터가 저장된 메모를 탐지하여 해제하는 기법.

가비지를 회수 하여 메모리 공간을 늘려 메모리 재사용이 가능하다.

### **장점**

- 자동적으로 사용하지 않는 메모리를 해제메모리 누수에 걱정이 없다.

### **단점**

- 자동적으로 메모리를 해제 한다고 하나 그 시점이 정확하지 않아 실시간 시스템에 적합하지가 않다.
- 해제 작업에 비용이 들기 때문에 오버헤드가 된다.

### **가비지 컬렉션 발생 시기**

- 메모리 영역이 충분하지 않은 상황에서 Heap 메모리에 동적 할당되면 가비지 컬렉터가 실행하며 사용하지 않은 메모리를 수거합니다.
- 가비지 컬렉터는 가끔식 실행이 되지만 시점을 알기 어려우며 플렛폼마다 다르게 발생합니다.

### **가비지 컬렉터(Garbage Collector)**

- **가비지 컬렉션이 쓰레기를 수집하는 역할**이라면 **가비지 컬렉터는 쓰레기를 수집하는 수집기**라고 보시면 됩니다.
- 동적으로 할당된 메모리가 더이상 사용되지 않을때 가비지 컬렉터들이 **탐색 → 분리 → 수집**을 합니다.

### Mark 와 Sweep

**Mark**

GC 가 스택의 모든 변수 및 객체를 스캔 하면서 각각 어떤 객체를 참고하고 있는 지 찾는 것

**Sweep**

Mark 되어 있지 않은 객체 틀에서 제거

## Object와 Class

### Object

- 설계도로 구현한 모든 대상. 유무형의 모든 것.
  - 속성: 상태값
  - 행위: 동작, 기능
- 시스템의 동적인 구성

### Class

- 설계도. 객체를 찍어내는 역할.
  - 속성 → 변수
  - 행위 → 메소드
- 시스템의 정적인 구성요소

![image](https://user-images.githubusercontent.com/52230415/115141898-bd290080-a079-11eb-8a3a-0dcbc9d7a30c.png)

## Instance와 Object

### Instance

- 객체에 메모리가 할당되어 실제로 활용되는 실체

### Object

- 클래스를 기반으로 선언된 대상
- 클래스의 인스턴스

## 생성자

객체 생성시 객체를 초기화하는 메소드

### 생성자 특징

- 클래스이름과 같아야한다
- 리턴타입 없다
- 오버로딩 가능하다 = 매개변수 개수와 타입이 달라야한다
- 상속되지 않는다
- 클래스 안에서 생성자가 1개도 없을 때 컴파일러에 의해 자동으로 기본생성자가 추가된다

## 오버로딩과 오버라이딩

### 오버로딩

- 다중 정의
- 같은 이름의 메서드 + 매개변수의 타입과 개수 다름

```java
void hi(){
	System.out.println("hi - 매개변수 없음");
 }
    
void hi(int num){
	for(int i=0; i<num; i++){
		System.out.println("hi " + i + "- 정수형 매개변수 있음");
	}	
}

void hi(String name){
	System.out.println("hi "+ name);
}
```

### 오버라이딩

- 부모 클래스가 가지고 있는 메서드를 자식 클래스가 재정의하는 방식

## 인터페이스와 추상클래스

### 추상클래스

- 미완성의(덜 구현된) 클래스. 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스이다.
- **is-a** 관계이다. **다중상속 불가능**하다.
- 추상메소드를 지닌 클래스. 단 추상메소드가 없지만 강제로 추상클래스로 선언 가능하다.

추상클래스는 **new 연산자로 객체 생성이 불가능**하다.

부모 클래스인 추상클래스에  추상메소드 유무에 따라 자식클래스의 입장

- 추상메소드가 있을 때, 자식클래스는 추상매소드를 **반드시 재정의**해야 하는 책임이 있다.
- 추상메소드가 없을 때, 자식클래스는 추상클래스의 메소드를 **선택적 재정의**할 수 있다.

### 인터페이스

- **기본 설계도**이다. 사용자 입장에서 **사용하는 방법**을 정의해둔 것이다.
- **has-a** 관계이다. **다중상속 가능**하다.
- **같은 기능**이 필요할 경우 인터페이스 사용된다.

## 객체 직렬화와 역직렬화

자바에서 입출력을 할 때 **스트림이라는 통로를 통해 데이터가 이동**한다. 하지만 **객체는 바이트형이 아니라서** 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없다.

객체를 스트림을 통해 입출력하려면 **바이트 배열로 변환**이 필요하다.

### 객체 직렬화

객체직렬화

= **객체를 데이터 스트림으로 만드는 것**

= 객체에 저장된 데이터를 스트림에 쓰기(write)위해 **연속적인(serial) 데이터로 변환**하는 것

- ObjectInputStream

  입력 단위를 객체 단위로 처리해주는 스트림

  직렬화 대상 객체의 Class는   **java.io.Serializable**을 반드시 상속받아야한다.

### 객체 역직렬화

직렬화되어 있는 객체의 상태값을 기반으로 객체로 복원시켜주는 것

스트림으로부터 데이터를 읽어서 객체를 만드는 것

- ObjectOutputStream

  출력 단위를 객체 단위로 처리해주는 스트림

## JVM

JVM(자바가상머신)이 .java의 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 변환하여 전달

**왜 자바 가상머신을 알아야 하는가?**

한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서가 그 답이 될지 모르겠다. 메모리 효율성을 위해 메모리 구조를 알아야 하기 때문

## JVM  구조

![image](https://user-images.githubusercontent.com/52230415/115141914-d0d46700-a079-11eb-9249-c8fbe5bb6976.png)

![image](https://user-images.githubusercontent.com/52230415/115141920-d9c53880-a079-11eb-8b2c-760cdb06591e.png)

**클래스 로더(Class Loader)**

- JVM 내로 클래스(.class)파일을 로드하고, 링크를 통해 배치하는 작업을 수행합니다. Runtime 시에 동적으로 클래스를 로드합니다. **.jar 파일** 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제합니다.
- 자바는 동적 로딩(Dynamic Loading) 을 지원합니다. 따라서 컴파일 타임에 모든 클래스가 로딩되지 않고 필요한 시점에 (런타임 도중) 해당 클래스를 실행하고 로딩합니다. 그 역할을 Class Loader 가 하는것입니다.

**실행 엔진(Execution Engine)**

- 클래스를 실행시키는 역할 입니다. 클래스 로더에 의해 JVM 내에 로딩된 클래스 파일(바이트 코드)은 실행 엔진에 의해 실행되어 컴퓨터가 이해할 수 있는 기계어로 변환합니다.

**인터프리터(Interpreter)**

- 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 해석합니다. 이는 자바의 단점으로 한줄 씩 읽어서 속도가 느립니다.

**JIT(Just - In - Time)**

- 인터프리터의 단점을 보완하기 위해 도입된 JIT 입니다. 인터프리터로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일 하여 기계어(네이티브 코드)로 변경 캐시에 저장합니다. 캐시에 보관된 네이티브 코드를 사용하기 때문에 한 번 컴파일 된 후에는 빠르게 수행할 수 있습니다. 하지만 JIT로 컴파일 하는 과정이 당연히 인터프리팅 하는것보다 느리기 때문에 한번만 실행되는 코드라면 인터프리팅 하는것이 유용합니다.

**가비지 컬렉터(Garbage Collector)**

- GC를 수행하는 모듈(쓰레드) 가 있습니다.

**메모리 상 공간(Runtime Data Area)**

- JVM 이 OS 로 부터 할당받은 메모리 공간입니다.
![image](https://user-images.githubusercontent.com/52230415/115141925-e5b0fa80-a079-11eb-91d6-80d056d5405d.png)

**PC Register**

- Thread 가 시작될 때 함께 생성되는 공간으로 스레드 마다 하나씩 존재합니다. 스레드가 어떤 부분을 어떤 명령으로 실행해야 할 지에 대한것을 기록하는 부분으로 현재 수행중인 JVM 의 명령 주소를 가집니다 .

**JVM 스택 영역(JVM Stack)**

- 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역입니다. 각종 형태의 변수나 임시 데이터, 스레드나 **메서드의 정보를 저장**합니다. 메소드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성됩니다. 이곳에 메서드 안에서 사용되는 값들을 저장합니다. 호출된 매개변수, 지역변수, 리턴 값 및 연산 시 변화하는 값들을 임시로 저장합니다. 메서드 수행이 끝나면 프레임 별로 삭제합니다.

**Native Method Stack**

- 자바 프로그램이 컴파일 되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다. JAVA 가 아닌 다른 언어로 작성된 코드를 위한 공간입니다. JAVA Native interface 로 인해 바이트코드로 변환하여 저장됩니다. 일반 프로그램 처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역입니다.

**Method Area (= Class Area = Static Area )**

- 클래스 정보를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장하기 위한 공간**입니다. 올라가게 되는 메서드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드입니다. 자바는 main 메서드로 부터 객체 생성 메소드 호출의 흐름을 이어가기 때문에 **거의 모든 바이트 코드가 올라간다고** 보면 됩니다.

이 공간에는 **Runtime Constant Pool** 이라는 공간이 존재하는 데 이는 상수 자료형을 저장하여 참조하고 중복을 막기위한 공간입니다.

- 올라가는 정보의 종류
- 멤버변수, 메서드에 대한 정보 (이름, 타입 접근제어자 등등)
- class 인지 interface 인지의 여부 저장, Type 의 속성 , 전체 이름, super class 의 전체이름(interface 이거나 object인 경우 제외)

Method Area 는 클래스를 위한 공간이라면 Heap 영역은 객체를 위한 공간입니다.

Heap 과 마찬가지로 Method Area 도 GC의 관리 대상이 됩니다.

**Heap 영역**

- 객체를 저장하는 가상 메모리 공간입니다. new 연산자로 생성된 객체와 배열을 저장합니다. 물론 Class Area 에 올라온 클래스들만 객체로 생성할 수 있습니다.

![image](https://user-images.githubusercontent.com/52230415/115141933-f06b8f80-a079-11eb-8ec0-7cc4cf75a4a9.png)

**Permanent 영역**

- 생성된 객체들의 주소값이 저장된 공간입니다. Class Loader 에 의해 로드되는 Class, Method 등에 대한 Meta 데이터가 저장되는 영역이고 JVM에 의해 사용됩니다. Reflection을 사용해 동적으로 클래스가 로딩 되는 경우에 사용합니다. 내부적으로 Reflection 을 자주 사용하는 Spring Framework를 사용한다면 이 영역에 대한 고려가 필요합니다.

Java 8부터는 **Permanent 영역대신 Metaspcae 로 호출되는 네이티브 영역에 저장**됩니다.

**New / Young 영역**

- Eden : 객체들이 최초로 생성되는 공간입니다.
- Survivor 0 / 1 : Eden 에 의해 참조되는 객체들이 저장되는 공간입니다.

**Old 영역**

- New / Young 영역에서 일정 시간 참조되고 난 뒤, 살아남은 객체들이 저장되는 공간입니다.

Eden 에서 객체가 가득 차면 첫 번째 GC (minor GC) 가 발생하고 Eden 영역에 있는 값들을

Survivor 1 영역에 복사하고 이 영역을 제외한 나머지 영역의 객체들을 삭제합니다.

인스턴스는 소멸 방법과 소멸 시점이 지역 변수와는 다르기 때문에 힙이라는 별도의 영역에 할당됩니다.

JVM 은 매우 합리적으로 더이상 인스턴스가 존재할 필요가 없을 때 인스턴스를 소멸시킵니다.
