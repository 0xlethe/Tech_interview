## Java 프로그래밍

- 운영체제 독립적
- 객체지향 언어
- 자동 메모리 관리(Garbage Collector)
- 동적 로딩(Dynamic Loading)
- 멀티스레드 지원

### JVM (Java Virtual Machine)

1. JVM은 Bytecode를 구동하고 있는 OS에 맞추어 BinaryCode로 해석(Interpret)합니다. 그러므로 **JAVA 프로그램은 OS에 독립적**입니다. (Platform Independence)
2. Bytecode는 클래스 단위(.class)로 생성되므로, 프로그램의 수정이 일어나더라도 **전체 소스코드를 다시 컴파일할 필요가 없습니다.**
3. 프로그램이 실행되는 도중에도 **JVM은 OS로부터 메모리를 할당받아 스스로 관리**합니다. 대표적으로 GC(Garbage Collection)이 있습니다.

### 자바 메모리 영역

- 메서드 영역 : **static 변수, 전역변수, 코드**에서 사용되는 Class 정보 등이 올라간다. 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.
- 스택(Stack) : **지역변수, 함수(메서드)** 등이 할당되는 LIFO(Last In First Out) 방식의 메모리
- 힙(Heap) : **new 연산자를 통한 동적 할당된 객체**들이 저장되며, Garbage 컬렉션에 의해 메모리가 관리되어 진다.

### 자바 바이트코드

- 자바에서 코드를 컴파일하면 바이트코드 즉 (.class)형태로 출력됩니다. 이 Class형태는 **JVM에 의해 런타임시 완벽한 기계코드로 변경**되어 실행됩니다.
- 바이트 코드를 완전한 기계코드로 변환하는 과정에서 일반적인 컴파일 언어보다 속도가 많이 느리다는 단점이 있습니다.

## Java SE와 Java EE 애플리케이션 비교

### Java SE(Java Platform Standard Edition)

데스크톱, 서버, 임베디드를 위한 표준 자바 플랫폼을 말합니다. 안드로이드를 개발할 때 보통 Java SE로 개발을 합니다.

### Java EE(Java Platform Enterprise Edition)

자바를 이용한 서버측 개발을 위한 플랫폼입니다. SE에 서버측을 위한 기능을 추가하여 SE의 모든 기능을 이용 할 수 있습니다.

## Java 접근제어자

클래스나 멤버변수와 메서드에 주로 사용되며 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.

**static (클래스의, 공통적인)**

- 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
- 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)
- 멤버변수
  - 모든 인스턴스에 공통적으로 상용되는 클래스변수가 된다.
  - 클래스변수는 인스턴스를 생성하지 않고도 사용가능하다.
  - 클래스가 메모리에 로드될 때 생성된다.
- 메서드
  - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
  - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

**final (마지막의, 변경될 수 없는)**

- 클래스
  - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
  - final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
- 메서드
  - 변경될 수 없는 메소드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
- 멤버변수, 지역변수
  - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

**abstract (추상의, 미완성의)**

- 멤버변수:
  - 클래스 내에 추상메서드가 선언되어 있음을 의미한다.
- 메서드:
  - 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다.

접근 제어자

- **private**: 같은 클래스 내에서만 접근이 가능하다.
- **default**: 같은 패키지 내에서만 접근이 가능하다.
- **protected**: 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
- **public**: 접근 제한이 전혀 없다.

## 데이터타입

### 원시데이터(Primitive type)

- 논리형
- 문자형
- 산술형
  - 정수
  - 실수

![image](https://user-images.githubusercontent.com/52230415/115141823-54418880-a079-11eb-948d-c149354b7f39.png)

**특징**

- 주어진 type의 크기만큼 공간이 할당된다. 그 안에 값이 직접 저장된다.

### 참조데이터(Reference Type)

원시 타입을 제외한 타입들(문자열, 배열, 열거, 클래스, 인터페이스)을 말한다.

```java
String s1 = new String("YeonJu");
Person p1 = new Person();
```

**특징**

- 객체의 참조값(메모리 주소)을 공간에 저장한다.
  - **스택(Stack) 영역에는 참조 변수가 할당**되고 **생성된 객체의 주소**가 저장
  - **객체는** new 연산자에 의해 생성되어 **동적 메모리 힙(Heap) 영역**에 저장
- 참조타입 변수는 크기가 정해져 있지 않다. ****프로그램 실행시 메모리에 동적으로 할당되기 떄문이다.
- **힙영역에 있는 객체를 참조하는 변수가 없을 때 가비지 컬렉터가 해당 객체를 제거**한다.
- 사용하는 메모리양이 상대적으로 많다. 아래 그림 참조.

![image](https://user-images.githubusercontent.com/52230415/115141846-73d8b100-a079-11eb-8c1d-49f2d27c1414.png)


## Boxing과 Unboxing

### Boxing

Primitive type  →→  Refernce type

### Unboxing

Refernce type  →→  Primitive type

자바 1.5 이후 부터 Auto Boxing/ Auto Unboxing으로 명시적으로 원시타입을 참조타입으로 변환시켜주지 않아도 자동으로 Boxing / Unboxing한다. 하지만 이러한 기능은 메모리 누수 원인일 될 수 있다.

```java
int price = 1000;
Integer newPrice = i + 500;
```

## Wrapper Class

- 8개의 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스
- 각각의 타입에 해당하는 데이터를 인수로 전달받아 해당 값을 가지는 객체로 만들어 준다.
- Wrapper 클래스를 이용할 때 주의할 점은 참조형끼리 연산이 불가능하기 때문에 기본 자료형으로 변환하여 연산해야 한다

### Wrapper Class 사용 목적

- 기본 자료형에 대해 객체로서 인식되도록 포장하기 위해 Wrapper class 사용
- 기본 자료형에 대한 다형성을 지원

## 제네릭

클래스나 메소드에서 사용할 **내부 데이터 타입을 컴파일 시에 미리 지정**하는 방법

![image](https://user-images.githubusercontent.com/52230415/115141857-8521bd80-a079-11eb-8d17-82d0b54f3671.png)

### 제네릭 장점

- **타입 안정성. 컴파일할 때 타입을 체크**해서 에러를 사전에 잡을 수 있습니다.
- Collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없다.
- 컴파일러가 타입캐스팅을 해주기 때문에 개발자가 편리합니다.
- 타입만 다르고 코드의 내용이 대부분 일치할 때 **코드의 재사용성**이 좋아집니다.

### 제네릭 단점

- 처음 코드를 보는 사람들한테는 조금 어렵게 보여 가독성 측면에서는 좋지 않을 수 있다.

### 제네릭 사용 예시

Collection에 특정 객체만 추가될 수 있도록 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 한다

## OOP 4가지 특징

### 캡슐화 "정보은닉"

- 객체의 필드(속성), 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것을 말한다.
- 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.
- 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.

### 상속 "계층성"

- 기존 클래스의 변수와 메소드를 그대로 가지면서 추가적인 기능도 가지는 클래스를 새로 만드는 것입니다. 복잡한 문제를 나누어서 공통 부분부터 구현하기 위해 사용합니다.
- 자식(하위,파생) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것
- 자식이 부모를 선택해서 물려 받는 것
- 상속 대상: 부모의 필드와 메소드
- 장점
  - 부모 클래스를 재사용해서 자식 클래스를 빨리 개발할 수 있다.
  - 반복된 코드의 중복을 줄여준다.
  - 유지 보수의 편리성을 제공해 준다.
  - 객체의 다형성을 구현할 수 있다.

### 다형성 "모듈화"

- 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킨다.

### 추상화 "모델링"

- 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 줄이는 방법
- 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다. (= 객체지향 관점에서 클래스를 정의하는 것.)
- 복잡성을 다루기 위한 추상화의 두 차원
  1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것
  2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것

## 상속과 합성(컴포지션)의 차이

### 상속

- is a 관계
- 클래스를 확장하여 부모 클래스에서 속성 및 동작을 상속

### 컴포지션

- has a 관계
- 클래스가 구성원 데이터로 다른 클래스의 객체를 포함

## OOP의 5대 원칙(SOLID)

객체 지향 설계 5원칙은 SOLID원칙이라고 불리기도 하는데요, 시스템의 **결합도는 낮추고 응집도를 높이는** 고전 원칙을 객체 지향 관점에서 5가지 원칙으로 재정립 한 것입니다.

- **단일책임원칙 Single Responsibility Principle**

  단일 책임 법칙각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 한다.

  ex) 어떤 클래스의 정보를 변경했을 때 다른 객체가 영향을 받으면 Side Effect가 크다고 한다.

- **개방폐쇄법칙 Open Close Principle**

  각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 한다.즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정한다.

- **리스코프 치환 법칙 Liskov Substitusion Principle**

  자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 한다.

- **Interface Segreation Principle 인터페이스 분리 법칙**

  각 행위에 대한 인터페이스는 서로 분리되어야 한다.핸드폰을 예로 들면, 전화를 하는데 핸드폰 카메라가 방해가 되면 안된다는 말.

- **의존성 역전 법칙 Dependency Inversion Principle**

  상위 클래스가 하위 클래스에 의존하면 안된다는 법칙. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안된다.

